/* _f is assumed to be analytic in D_r^*(_a)for some r */

residue_m(_f, _z, _a) := block(
ratprint: false,
[res, lim],
lim: limit(abs(_f), _z, _a),
/* if we have an essential singularity at _a, we use residue_powerseries() */
if undefinedp(lim)
  then res: residue_powerseries(_f, _z, _a)
  /* else we try the original residue() */
  else block(
    [], 
    lis: errcatch(residue(_f, _z, _a)),
    /* if residue() fails, we use residue_lim */
    if emptyp(lis)
      then res: residue_lim(_f, _z, _a)
      else block(
        [],
        res: first(lis),
        if is(equal(res, 0)) and infinitep(lim)
          then res: residue_lim(_f, _z, _a))),
res
);


infinitep(_e) := block(
[],
if atom(_e)
  then return(is(equal(_e, infinity) or equal(_e, inf) or equal(_e, minf)))
  else return(is(member(infinity, args(_e)) or member(inf, args(_e)) or member(minf, args(_e))))
);


undefinedp(_e) := block(
[],
if atom(_e)
  then return(is(member(ind, list(_e)) or member(und, list(_e))))
  else return(is(member(ind, args(_e)) or member(und, args(_e))))
);


/* largest order to check */
define_variable(residue_max_pole_order, 10, integer);


residue_lim(_f,_z,_a):=block(
[j,res,l],
l: for j: 1 thru residue_max_pole_order do (
    /* display(j), */
    res: limit(diff((_z-_a)^j*_f,_z,j-1),_z,_a)/(j-1)!,
    if not infinitep(res) then return(res)),
if is(equal(l, done)) 
  then return("The pole is of large order, please check and reset residue_max_pole_order and try again"),
return(l)
);


residue_powerseries(_f,_z,_a):=block(
[s,sp,ai,n,nn,ff],
ref:0,
s:powerseries(_f,_z,_a),
sp:niceindices(s),
ai:part(sp,1), /*this assumes that powerseries is self-contained, with no prefactors*/
n:hipow(ai,z),
nn:solve(n=-1),
ff:is(round(part(nn,1,2))=part(nn,1,2)), /* ?? integer that gives 1/(z-a) term ??*/
if (ff) then ref:(_z-_a)*subst(nn,ai),
ref
);


expp(_f) := is(equal(op(_f), "^")) and is(equal(first(args(_f)), %e));


residue_valid_op_p(_f, _z) := block(
[list_of_ops],
list_of_ops: [sin, cos, tan],
constantp(_f) or polynomialp(_f, [_z]) or expp(_f) or is(member(op(_f), list_of_ops)) 
);


residue_taylor_expand(_f, _z, _a, optr) := block(
[arg, s, sz],
arg: last(args(_f)),
s: taylor(optr(_z), _z, _a, 10),
sz: subst(_z = arg, s)
);


residue_taylor_one_term(_f, _z, _a) := block(
[optr, res],
if constantp(_f) or polynomialp(_f, [_z])
  then return(taylor(_f, _z, _a, 10))
  else block(
    optr: op(_f),
    if residue_valid_op_p(_f, _z)
      then block(
      [],
      if is(equal(optr, "^"))
        then optr: exp,
      res: residue_taylor_expand(_f, _z, _a, optr))
      else res: "failed")
);


residue_taylor_multi_terms(_f, _z, _a) := block(
[product],
product: 1,
for i: 1 thru length(args(_f)) do (
          term: part(_f, i),
          o: op(term),
          product: product * residue_taylor_one_term(term, _z, _a))
);


residue_taylor(_f, _z, _a) := block(
[temp, res],
if residue_valid_op_p(_f, _z)
  then res: coeff(residue_taylor_one_term(_f, _z, _a), _z-_a, -1)
  else block(
    [optr],
    optr: op(_f),
    if is(equal(optr, "*") or equal(optr, "/"))
      then block(
        [product],
        product: 1,
        num: num(_f),
        denom: denom(_f),
        if residue_valid_op_p(num, _z)
          then product: product * residue_taylor_one_term(num, _z, _a)
          else product: product * residue_taylor_multi_terms(num, _z, _a),
        if residue_valid_op_p(denom, _z)
          then product: product * (1/residue_taylor_one_term(denom, _z, _a))
          else product: product * (1/residue_taylor_multi_terms(denom, _z, _a)),
        res: coeff(expand(product), _z-_a, -1)))
);